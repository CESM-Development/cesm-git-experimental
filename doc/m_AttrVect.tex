%                **** IMPORTANT NOTICE *****
% This LaTeX file has been automatically produced by ProTeX v. 1.0
% Any changes made to this file will likely be lost next time
% this file is regenerated from its Fortran source.
% Send questions to Arlindo da Silva, dasilva@gsfc.nasa.gov
 
\parskip        0pt
\parindent      0pt
\baselineskip  11pt
 
%--------------------- SHORT-HAND MACROS ----------------------
\def\bv{\begin{verbatim}}
\def\ev{\end{verbatim}}
\def\be{\begin{equation}}
\def\ee{\end{equation}}
\def\bea{\begin{eqnarray}}
\def\eea{\end{eqnarray}}
\def\bi{\begin{itemize}}
\def\ei{\end{itemize}}
\def\bn{\begin{enumerate}}
\def\en{\end{enumerate}}
\def\bd{\begin{description}}
\def\ed{\end{description}}
\def\({\left (}
\def\){\right )}
\def\[{\left [}
\def\]{\right ]}
\def\<{\left  \langle}
\def\>{\right \rangle}
\def\cI{{\cal I}}
\def\diag{\mathop{\rm diag}}
\def\tr{\mathop{\rm tr}}
%-------------------------------------------------------------
 
%/////////////////////////////////////////////////////////////

 \subsection{Module m\_AttrVect - a distributed Innovation vector}


 
 
  An {\em attribute vector} is a scheme for storing bundles of integer 
  and real data vectors, indexed by lists of their respective attributes.
  The attribute vector is implemented in Fortran 90 using the 
  {\tt AttrVect} derived type.  This module contains the definition of
  {\tt AttrVect} class, and numerous methods that service it.
 
\bigskip{\sf INTERFACE:}
\begin{verbatim} 
 module m_AttrVect\end{verbatim}{\em USES:}
\begin{verbatim}      use m_List, only : List     Support for rList and iList components.
 
      implicit none
 
      private	  except
 
      public :: AttrVect          The class data structure
 
      public :: init		  create a local vector
      public :: clean		  clean the local vector
      public :: lsize		  size of the local vector
      public :: nIAttr		  number of integer attributes on local
      public :: nRAttr		  number of real attributes on local
      public :: indexIA		  index the integer attributes
      public :: indexRA		  index the real attributes
      public :: getIList          return list of integer attributes
      public :: getRList          return list of real attributes
      public :: Sort              sort entries, and return permutation
      public :: Permute           permute entries
      public :: SortPermute       sort and permute entries
 
    type AttrVect
      type(List) :: iList
      type(List) :: rList
      integer,dimension(:,:),pointer :: iAttr
      real   ,dimension(:,:),pointer :: rAttr
    end type AttrVect
 
    interface init   ; module procedure	&
 init_,	&
 initv_
    end interface
    interface clean  ; module procedure clean_  ; end interface
    interface lsize  ; module procedure lsize_  ; end interface
    interface nIAttr ; module procedure nIAttr_ ; end interface
    interface nRAttr ; module procedure nRAttr_ ; end interface
    interface indexIA; module procedure indexIA_; end interface
    interface indexRA; module procedure indexRA_; end interface
    interface getIList; module procedure getIList_; end interface
    interface getRList; module procedure getRList_; end interface
    interface Sort    ; module procedure Sort_    ; end interface
    interface Permute ; module procedure Permute_ ; end interface
    interface SortPermute ; module procedure SortPermute_ ; end interface
 \end{verbatim}{\sf REVISION HISTORY:}
\begin{verbatim}  	10Apr98 - Jing Guo <guo@thunder> - initial prototype/prolog/code
  	10Oct00 - J.W. Larson <larson@mcs.anl.gov> - made getIList
                  and getRList functions public and added appropriate
                  interface definitions
        20Oct00 - J.W. Larson <larson@mcs.anl.gov> - added Sort, 
                  Permute, and SortPermute functions.\end{verbatim}
 
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\ 
 

 \subsubsection{init\_ - initialize with given iList, rList, and the size}


 
 
\bigskip{\sf INTERFACE:}
\begin{verbatim} 
 subroutine init_(aV,iList,rList,lsize)\end{verbatim}{\em USES:}
\begin{verbatim}      use m_List, only : init,nitem
      use m_mall
      use m_die
      implicit none
      type(AttrVect),intent(out) :: aV
      character(len=*),optional,intent(in) :: iList
      character(len=*),optional,intent(in) :: rList
      integer,         optional,intent(in) :: lsize
 \end{verbatim}{\sf REVISION HISTORY:}
\begin{verbatim}  	09Apr98 - Jing Guo <guo@thunder> - initial prototype/prolog/code\end{verbatim}
 
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\ 
 

 \subsubsection{initv\_ - initialize on the vectors}


 
 
\bigskip{\sf INTERFACE:}
\begin{verbatim} 
 subroutine initv_(aV,bV,lsize)\end{verbatim}{\em USES:}
\begin{verbatim}      use m_String, only : String,char
      use m_List,   only : get
 
      implicit none
 
      type(AttrVect),intent(out) :: aV
      type(AttrVect),intent(in)  :: bV
      integer,       intent(in)  :: lsize
 \end{verbatim}{\sf REVISION HISTORY:}
\begin{verbatim}  	22Apr98 - Jing Guo <guo@thunder> - initial prototype/prolog/code\end{verbatim}
 
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\ 
 

 \subsubsection{clean\_ - clean a vector}


 
 
\bigskip{\sf INTERFACE:}
\begin{verbatim} 
 subroutine clean_(aV)\end{verbatim}{\em USES:}
\begin{verbatim}      use m_mall
      use m_stdio
      use m_die
      use m_List, only : clean
 
      implicit none
 
      type(AttrVect),intent(inout) :: aV
 \end{verbatim}{\sf REVISION HISTORY:}
\begin{verbatim}  	09Apr98 - Jing Guo <guo@thunder> - initial prototype/prolog/code\end{verbatim}
 
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\ 
 

 \subsubsection{lsize\_ - the local size of the vector}


 
 
\bigskip{\sf INTERFACE:}
\begin{verbatim} 
 function lsize_(aV)
 
     implicit none
 
      type(AttrVect), intent(in) :: aV
      integer :: lsize_
 \end{verbatim}{\sf REVISION HISTORY:}
\begin{verbatim}  	09Apr98 - Jing Guo <guo@thunder> - initial prototype/prolog/code\end{verbatim}
 
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\ 
 

 \subsubsection{nIAttr\_ - number of INTEGER type attributes}


 
 
\bigskip{\sf INTERFACE:}
\begin{verbatim} 
 function nIAttr_(aV)\end{verbatim}{\em USES:}
\begin{verbatim}      use m_List, only : nitem
 
      implicit none
      type(AttrVect),intent(in) :: aV
      integer :: nIAttr_
 \end{verbatim}{\sf REVISION HISTORY:}
\begin{verbatim}  	22Apr98 - Jing Guo <guo@thunder> - initial prototype/prolog/code\end{verbatim}
 
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\ 
 

 \subsubsection{nRAttr\_ - number of REAL type attributes}


 
 
\bigskip{\sf INTERFACE:}
\begin{verbatim} 
 function nRAttr_(aV)\end{verbatim}{\em USES:}
\begin{verbatim}      use m_List, only : nitem
 
      implicit none
 
      type(AttrVect),intent(in) :: aV
      integer :: nRAttr_
 \end{verbatim}{\sf REVISION HISTORY:}
\begin{verbatim}  	22Apr98 - Jing Guo <guo@thunder> - initial prototype/prolog/code\end{verbatim}
 
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\ 
 

 \subsubsection{getIList\_ - get an item from iList}


 
 
\bigskip{\sf INTERFACE:}
\begin{verbatim} 
 subroutine getIList_(item,ith,aVect)\end{verbatim}{\em USES:}
\begin{verbatim}      use m_String, only : String
      use m_List,   only : get
 
      implicit none
 
      type(String),intent(out) :: item
      integer,     intent(in)  :: ith
      type(AttrVect),intent(in) :: aVect
 \end{verbatim}{\sf REVISION HISTORY:}
\begin{verbatim}  	24Apr98 - Jing Guo <guo@thunder> - initial prototype/prolog/code\end{verbatim}
 
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\ 
 

 \subsubsection{getRList\_ - get an item from rList}


 
 
\bigskip{\sf INTERFACE:}
\begin{verbatim} 
 subroutine getRList_(item,ith,aVect)\end{verbatim}{\em USES:}
\begin{verbatim}      use m_String, only : String
      use m_List,   only : get
 
      implicit none
 
      type(String),intent(out) :: item
      integer,     intent(in)  :: ith
      type(AttrVect),intent(in) :: aVect
 \end{verbatim}{\sf REVISION HISTORY:}
\begin{verbatim}  	24Apr98 - Jing Guo <guo@thunder> - initial prototype/prolog/code\end{verbatim}
 
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\ 
 

 \subsubsection{indexIA\_ - index the integer attribute List}


 
 
\bigskip{\sf INTERFACE:}
\begin{verbatim} 
 function indexIA_(aV,item,perrWith,dieWith)\end{verbatim}{\em USES:}
\begin{verbatim}      use m_List, only : index
      use m_die,  only : die
      use m_stdio,only : stderr
 
      implicit none
 
      type(AttrVect), intent(in) :: aV
      character(len=*),intent(in) :: item
      character(len=*),optional,intent(in) :: perrWith
      character(len=*),optional,intent(in) :: dieWith
      integer :: indexIA_
 \end{verbatim}{\sf REVISION HISTORY:}
\begin{verbatim}  	27Apr98 - Jing Guo <guo@thunder> - initial prototype/prolog/code\end{verbatim}
 
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\ 
 

 \subsubsection{indexRA\_ - index the integer attribute List}


 
  
 
\bigskip{\sf INTERFACE:}
\begin{verbatim} 
 function indexRA_(aV,item,perrWith,dieWith)\end{verbatim}{\em USES:}
\begin{verbatim}      use m_List, only : index
      use m_die,  only : die
      use m_stdio,only : stderr
 
      implicit none
 
      type(AttrVect), intent(in) :: aV
      character(len=*),intent(in) :: item
      character(len=*),optional,intent(in) :: perrWith
      character(len=*),optional,intent(in) :: dieWith
      integer :: indexRA_
 \end{verbatim}{\sf REVISION HISTORY:}
\begin{verbatim}  	27Apr98 - Jing Guo <guo@thunder> - initial prototype/prolog/code\end{verbatim}
 
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\ 
 

 \subsubsection{Sort\_ - return index permutation keyed by a list of}


             attributes
 
  The subroutine {\tt Sort\_()} uses a list of keys defined by the {\tt List} 
  {\tt sList}, searches for the appropriate integer or real attributes
  referenced by the items in {\tt sList} ( that is, it identifies the 
  appropriate entries in {aV\%iList} and {\tt aV\%rList}), and then 
  uses these keys to generate a permutation {\tt perm} that will put
  the entries of the attribute vector {\tt aV} in lexicographic order
  as defined by {\tt sList} (the ordering in {\tt sList} being from
  left to right.
 
  {\bf N.B.:}  This routine will fail if {\tt aV\%rList} and 
  {\tt aV\%rList} share one or more common entries. 
 
  {\bf N.B.:}  This routine will fail if {\tt aV\%rList} and 
 
\bigskip{\sf INTERFACE:}
\begin{verbatim} 
 subroutine Sort_(aV, sList, perm, descend, perrWith, dieWith)\end{verbatim}{\em USES:}
\begin{verbatim}      use m_String,        only : String
      use m_String,        only : String_tochar => tochar
      use m_List ,         only : List_index => index
      use m_List ,         only : List_nitem => nitem
      use m_List ,         only : List_get   => get
      use m_die ,          only : die
      use m_stdio ,        only : stderr
      use m_SortingTools , only : IndexSet
      use m_SortingTools , only : IndexSort
 
      implicit none
 
      type(AttrVect), intent(in)                  :: aV
      type(List),     intent(in)                  :: sList
      integer, dimension(:), pointer              :: perm
      logical, dimension(:), optional, intent(in) :: descend
      character(len=*), optional, intent(in)      :: perrWith
      character(len=*), optional, intent(in)      :: dieWith
 
 \end{verbatim}{\sf REVISION HISTORY:}
\begin{verbatim}  	20Oct00 - J.W. Larson <larson@mcs.anl.gov> - initial prototype\end{verbatim}
 
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\ 
 

 \subsubsection{Permute\_ - return index permutation keyed by a list of}


             attributes
 
  The subroutine {\tt Permute\_()} uses a a permutation {\tt perm} (which can
  be generated by the routine {\tt Sort\_()} in this module) to rearrange
  the entries in the attribute integer and real storage areas of the
  input attribute vector {\tt aV}--{\tt aV\%iAttr} and {\tt aV\%rAttr}, 
  respectively.
 
\bigskip{\sf INTERFACE:}
\begin{verbatim} 
 subroutine Permute_(aV, perm, perrWith, dieWith)\end{verbatim}{\em USES:}
\begin{verbatim}      use m_die ,          only : die
      use m_stdio ,        only : stderr
      use m_SortingTools , only : Permute
 
      implicit none
 
      type(AttrVect), intent(inout) :: aV
      integer, dimension(:), intent(in) :: perm
      character(len=*),optional,intent(in) :: perrWith
      character(len=*),optional,intent(in) :: dieWith
 \end{verbatim}{\sf REVISION HISTORY:}
\begin{verbatim}  	23Oct00 - J.W. Larson <larson@mcs.anl.gov> - initial prototype\end{verbatim}
 
%/////////////////////////////////////////////////////////////
 
\mbox{}\hrulefill\ 
 

 \subsubsection{SortPermute\_ - Place AttrVect data in lexicographic order.}


 
 
  The subroutine {\tt SortPermute\_()} uses the routine {\tt Sort\_()} 
  to create an index permutation {\tt perm} that will place the AttrVect
  entries in the lexicographic order defined by the keys in the List 
  variable {\tt key\_list}.  This permutation is then used by the routine
  {\tt Permute\_()} to place the AttreVect entries in lexicographic order.
 
\bigskip{\sf INTERFACE:}
\begin{verbatim} 
 subroutine SortPermute_(aV, key_list, descend, perrWith, dieWith)\end{verbatim}{\em USES:}
\begin{verbatim}      use m_die ,          only : die
      use m_stdio ,        only : stderr
 
      implicit none
 
      type(AttrVect), intent(inout) :: aV
      type(List), intent(in)        :: key_list
      logical , dimension(:), optional, intent(in) :: descend
      character(len=*), optional, intent(in) :: perrWith
      character(len=*), optional, intent(in) :: dieWith
 
 \end{verbatim}{\sf REVISION HISTORY:}
\begin{verbatim}  	24Oct00 - J.W. Larson <larson@mcs.anl.gov> - initial prototype\end{verbatim}

%...............................................................
